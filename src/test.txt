1、C++对C语言作了很多改进，下列描述中（　）使得C语言发生了质变，从面向过程变成了面向对象。
A、增加了一些新的运算符； B、允许函数重载，并允许设置缺省参数；
C、规定函数说明必须用原型； D、引进了类和对象的概念；
----D----
2、所谓数据封装就是将一组数据和与这组数据有关操作组装在一起，形成一个实体，这实体也就是( )。
A.类 B.对象 C.函数体 D.数据块
----A----
3、 关于new运算符的下列描述中，（　）是错误的。
A、 它可以用来动态创建对象和对象数组；
B、使用它创建的对象或对象数组可以使用运算符delete删除；
C、使用它创建对象时要调用构造函数；
D、使用它创建对象数组时必须指定初始值；
----D----
4、 （　）不是构造函数的特征。
A、构造函数的函数名与类名相同； 　B、构造函数可以重载；
C、构造函数可以设置缺省参数； 　D、构造函数必须指定类型说明。
----D----
5、 假定一个类的构造函数为B(int x,int y){a=x--;b=a*y--;},则执行B x(3,5); 语句后，x.a和x.b的值分别为( ) 
A、 3和5 B、 5和3 C、 3和15 D、20和5
----C----
6、 关于成员函数特征的下列描述中，（　）是错误的。
A、成员函数一定是内联函数； B、成员函数可以重载；
C、成员函数可以设置缺省参数值； 　D、成员函数可以是静态的；
----A----
7、 在公有继承的情况下，基类成员在派生类中的访问权限（　）。 
A.受限制 B.保持不变 C.受保护 D.不受保护
----B----
8、 友元的作用是（　）。
A、提高程序的运用效率； 　B、加强类的封装性；
C、实现数据的隐藏性； 　D、增加成员函数的种类；
----D----
9、 在C++中，关于下列设置缺省参数值的描述中，（　）是正确的。
A、不允许设置缺省参数值；
B、在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；
C、只能在函数的定义性声明中指定参数的缺省值；
D、设置缺省参数值时，必须全部都设置；
----B----
10、关于delete运算符的下列描述中，（　）是错误的。
A、它必须用于new返回的指针；
B、使用它删除对象时要调用析构函数；
C、对一个指针可以使用多次该运算符；
D、指针名前只有一对方括号符号，不管所删除数组的维数。
----B----
11、const int *p说明不能修改（　）。
A、p指针； 　 B、p指针指向的变量；
C、p指针指向的数据类型；D、上述A、B、C三者；
----B----
12、当需要打开A盘上的以xxk.dat文件用于输入时，则定义文件流对象的语句为 ( )。
A．fstream fin(“A:xxk.dat”,1) B．ifstream fin(“A:xxk.dat”,ios::nocreate)
C．ofstream fin(“A:xxk.dat”) D．ifstream fin(“A:xxk.dat”,ios::app)
----A----
13、派生类的对象对它的基类成员中（　）是可以访问的。
A、公有继承的公有成员； 　B、公有继承的私有成员；
C、公有继承的保护成员； D、私有继承的公有成员；
----A----
14、假定一个字符串的长度为n，则定义存储该字符串的字符数组的长度至少为（）。A．n-1 B．n C. n+1 D．n+2
----C----
15、 在int a=3; *p=&a;中，*p的值是（　）。
A、变量a的地址值 B、无意义 C、变量p的地址值 D、 3
----D----